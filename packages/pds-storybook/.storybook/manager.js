// .storybook/manager.js
// PDS Ontology-aware sidebar filtering for Storybook
// Uses experimental_setFilter API to enrich search with PDS ontology concepts
// ALL DATA IS LOADED FROM pds-reference.json (Single Source of Truth from pds-ontology.js)
import { addons } from '@storybook/manager-api';
import { STORY_CHANGED } from '@storybook/core-events';

const ADDON_ID = 'pds-ontology-filter';
const FILTER_ID = 'pds-ontology';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PDS ONTOLOGY - Loaded from SSoT (pds-reference.json)
// No hardcoded data here - everything comes from the ontology!
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/** @type {Object|null} Loaded reference data */
let referenceData = null;

/** @type {Map<string, Set<string>>} Term to related terms (from searchRelations + derived) */
let relationIndex = new Map();

/** @type {Map<string, Set<string>>} Category to member IDs/tags */
let categoryIndex = new Map();

/** @type {Map<string, Set<string>>} Tag to items that have that tag */
let tagIndex = new Map();

/** @type {Set<string>} All searchable words from ontology (for prefix matching) */
let allWords = new Set();

/** @type {Map<string, string[]>} Story ID to its pds.tags (extracted from story parameters) */
let storyTagsIndex = new Map();

/**
 * Build story tags index from the storyIndex in pds-reference.json
 * This is populated during loadOntology() from the pre-built reference data
 */
function buildStoryTagsIndex() {
  if (!referenceData?.storyIndex) return;
  
  let tagCount = 0;
  
  // Helper to convert title to Storybook ID format
  // "About PDS/What Is PDS" â†’ "about-pds-what-is-pds"
  const titleToId = (title) => {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9/\s-]/g, '')
      .replace(/[\s/]+/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  };
  
  Object.entries(referenceData.storyIndex).forEach(([slug, entry]) => {
    if (!Array.isArray(entry.tags) || entry.tags.length === 0) return;
    
    const normalizedTags = entry.tags.map(t => String(t).toLowerCase());
    
    // Compute the Storybook component ID from the title
    const componentId = entry.storyTitle ? titleToId(entry.storyTitle) : slug;
    
    // Index by multiple possible ID formats
    const idsToIndex = [
      slug.toLowerCase(),
      componentId,
      // Also add story variant IDs if we have story names
      ...(entry.stories || []).map(s => s.id?.toLowerCase()).filter(Boolean)
    ];
    
    idsToIndex.forEach(id => {
      if (id) {
        storyTagsIndex.set(id, normalizedTags);
      }
    });
    
    // Add tags to allWords for prefix matching
    normalizedTags.forEach(tag => {
      allWords.add(tag);
      // Add individual words from multi-word tags
      tag.split(/\s+/).forEach(word => {
        if (word.length >= 2) allWords.add(word);
      });
    });
    
    tagCount += normalizedTags.length;
  });
}

/**
 * Load ontology data from pds-reference.json
 * This file is generated by build-pds-reference.mjs from the SSoT (pds-ontology.js)
 */
async function loadOntology() {
  if (referenceData) return referenceData;
  
  try {
    // Use relative path so it works both in dev and when deployed to a subdirectory
    const response = await fetch('./pds-data/pds-reference.json');
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    referenceData = await response.json();
    buildIndices();
    buildStoryTagsIndex();
    return referenceData;
  } catch (err) {
    console.warn('PDS Ontology: Failed to load pds-reference.json', err);
    referenceData = { components: {}, ontologyData: {}, enhancements: [], tokens: {}, storyIndex: {} };
    return referenceData;
  }
}

/**
 * Build search indices entirely from loaded ontology data
 * NO HARDCODED DATA - everything derives from pds-ontology.js via pds-reference.json
 */
function buildIndices() {
  if (!referenceData) return;
  
  const od = referenceData.ontologyData || {};
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 1. Build relationIndex from searchRelations (SSoT)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const searchRelations = od.searchRelations || {};
  
  // Bidirectional: if "text" â†’ ["typography", "truncate"], then also "typography" â†’ ["text"]
  Object.entries(searchRelations).forEach(([key, related]) => {
    const keyLower = key.toLowerCase();
    if (!relationIndex.has(keyLower)) relationIndex.set(keyLower, new Set());
    
    (related || []).forEach(r => {
      const rLower = String(r).toLowerCase();
      relationIndex.get(keyLower).add(rLower);
      
      // Bidirectional mapping
      if (!relationIndex.has(rLower)) relationIndex.set(rLower, new Set());
      relationIndex.get(rLower).add(keyLower);
    });
  });
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 2. Build categoryIndex from categories and items
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const categories = od.categories || {};
  
  // Map declared categories to their member IDs
  Object.entries(categories).forEach(([cat, info]) => {
    const catLower = cat.toLowerCase();
    if (!categoryIndex.has(catLower)) categoryIndex.set(catLower, new Set());
    
    (info.primitives || []).forEach(id => categoryIndex.get(catLower).add(id.toLowerCase()));
    (info.components || []).forEach(id => categoryIndex.get(catLower).add(id.toLowerCase()));
    (info.patterns || []).forEach(id => categoryIndex.get(catLower).add(id.toLowerCase()));
  });
  
  // Also index items by their declared category
  (od.primitives || []).forEach(p => {
    const cat = (p.category || 'other').toLowerCase();
    if (!categoryIndex.has(cat)) categoryIndex.set(cat, new Set());
    categoryIndex.get(cat).add(p.id?.toLowerCase());
    (p.tags || []).forEach(t => categoryIndex.get(cat).add(t.toLowerCase()));
  });
  
  (od.components || []).forEach(c => {
    const cat = (c.category || 'other').toLowerCase();
    if (!categoryIndex.has(cat)) categoryIndex.set(cat, new Set());
    categoryIndex.get(cat).add(c.id?.toLowerCase());
    (c.tags || []).forEach(t => categoryIndex.get(cat).add(t.toLowerCase()));
  });
  
  (od.layoutPatterns || []).forEach(l => {
    const cat = (l.category || 'layout').toLowerCase();
    if (!categoryIndex.has(cat)) categoryIndex.set(cat, new Set());
    categoryIndex.get(cat).add(l.id?.toLowerCase());
    (l.tags || []).forEach(t => categoryIndex.get(cat).add(t.toLowerCase()));
    // Also add selector-derived terms (e.g., ".grid" â†’ "grid")
    (l.selectors || []).forEach(s => {
      const cleaned = s.replace(/[.#\[\]]/g, '').toLowerCase();
      if (cleaned) categoryIndex.get(cat).add(cleaned);
    });
  });
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 3. Build tagIndex from all item tags
  // Maps tags to the specific item IDs that have that tag (NOT the type!)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const indexItemTags = (items) => {
    (items || []).forEach(item => {
      const itemId = item.id?.toLowerCase();
      if (!itemId) return;
      
      (item.tags || []).forEach(tag => {
        const tagLower = tag.toLowerCase();
        if (!tagIndex.has(tagLower)) tagIndex.set(tagLower, new Set());
        tagIndex.get(tagLower).add(itemId);
        
        // Also add tagâ†’id relations (but NOT the generic type like 'primitive')
        if (!relationIndex.has(tagLower)) relationIndex.set(tagLower, new Set());
        relationIndex.get(tagLower).add(itemId);
      });
    });
  };
  
  indexItemTags(od.primitives);
  indexItemTags(od.components);
  indexItemTags(od.layoutPatterns);
  indexItemTags(od.enhancements);
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 4. Index utilities (text, backdrop, border, etc.)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const utilities = od.utilities || {};
  Object.entries(utilities).forEach(([group, value]) => {
    const groupLower = group.toLowerCase();
    if (!categoryIndex.has('utility')) categoryIndex.set('utility', new Set());
    categoryIndex.get('utility').add(groupLower);
    
    // If value is an object with arrays, index the class names
    if (typeof value === 'object' && value !== null) {
      Object.entries(value).forEach(([subgroup, classes]) => {
        if (Array.isArray(classes)) {
          classes.forEach(cls => {
            const cleaned = cls.replace(/[.#\[\]]/g, '').toLowerCase();
            if (!relationIndex.has(groupLower)) relationIndex.set(groupLower, new Set());
            relationIndex.get(groupLower).add(cleaned);
            // Bidirectional
            if (!relationIndex.has(cleaned)) relationIndex.set(cleaned, new Set());
            relationIndex.get(cleaned).add(groupLower);
          });
        }
      });
    }
  });
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 5. Index components from the components object (with pdsTags)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Object.values(referenceData.components || {}).forEach(comp => {
    const tag = comp.tag?.toLowerCase();
    const name = comp.displayName?.toLowerCase();
    const cat = (comp.ontology?.category || comp.category || 'other').toLowerCase();
    
    if (!categoryIndex.has(cat)) categoryIndex.set(cat, new Set());
    if (tag) categoryIndex.get(cat).add(tag);
    if (name) categoryIndex.get(cat).add(name);
    
    // Index component tags
    (comp.pdsTags || comp.ontology?.tags || []).forEach(t => {
      const tagLower = t.toLowerCase();
      if (!tagIndex.has(tagLower)) tagIndex.set(tagLower, new Set());
      tagIndex.get(tagLower).add(tag);
      
      if (!relationIndex.has(tagLower)) relationIndex.set(tagLower, new Set());
      relationIndex.get(tagLower).add(tag);
      if (tag) {
        if (!relationIndex.has(tag)) relationIndex.set(tag, new Set());
        relationIndex.get(tag).add(tagLower);
      }
    });
  });
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 6. Build allWords set for prefix matching
  // Collect ALL words from all indices for comprehensive prefix search
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  relationIndex.forEach((related, key) => {
    allWords.add(key);
    related.forEach(r => allWords.add(r));
  });
  categoryIndex.forEach((members, cat) => {
    allWords.add(cat);
    members.forEach(m => allWords.add(m));
  });
  tagIndex.forEach((items, tag) => {
    allWords.add(tag);
    items.forEach(i => allWords.add(i));
  });
  
  // Add words from components
  Object.values(referenceData.components || {}).forEach(comp => {
    if (comp.tag) allWords.add(comp.tag.toLowerCase());
    if (comp.displayName) allWords.add(comp.displayName.toLowerCase());
    (comp.pdsTags || comp.ontology?.tags || []).forEach(t => allWords.add(t.toLowerCase()));
  });
  
  // Add words from primitives
  (od.primitives || []).forEach(p => {
    if (p.id) allWords.add(p.id.toLowerCase());
    if (p.name) allWords.add(p.name.toLowerCase());
    (p.tags || []).forEach(t => allWords.add(t.toLowerCase()));
  });
  
  // Add words from enhancements
  (od.enhancements || []).forEach(e => {
    if (e.id) allWords.add(e.id.toLowerCase());
    if (e.name) allWords.add(e.name.toLowerCase());
    if (e.selector) allWords.add(e.selector.replace(/[[\]]/g, '').toLowerCase());
    (e.tags || []).forEach(t => allWords.add(t.toLowerCase()));
  });
}

/**
 * Normalize a word to its singular form (simple English rules)
 * Also returns the plural form so both directions match
 * @param {string} word - Word to normalize
 * @returns {string[]} - Array of [singular, plural] forms
 */
function normalizePlural(word) {
  const w = word.toLowerCase();
  const forms = new Set([w]);
  
  // Common irregular plurals
  const irregulars = {
    'children': 'child', 'child': 'children',
    'people': 'person', 'person': 'people',
    'men': 'man', 'man': 'men',
    'women': 'woman', 'woman': 'women',
    'mice': 'mouse', 'mouse': 'mice',
    'feet': 'foot', 'foot': 'feet',
    'teeth': 'tooth', 'tooth': 'teeth',
    'geese': 'goose', 'goose': 'geese',
    'indices': 'index', 'index': 'indices',
    'matrices': 'matrix', 'matrix': 'matrices',
    'vertices': 'vertex', 'vertex': 'vertices',
    'data': 'datum', 'datum': 'data',
    'media': 'medium', 'medium': 'media'
  };
  
  if (irregulars[w]) {
    forms.add(irregulars[w]);
    return [...forms];
  }
  
  // -ies â†’ -y (e.g., utilities â†’ utility)
  if (w.endsWith('ies')) {
    forms.add(w.slice(0, -3) + 'y');
  }
  // -y â†’ -ies (e.g., utility â†’ utilities)
  if (w.endsWith('y') && !['ay', 'ey', 'oy', 'uy'].some(v => w.endsWith(v))) {
    forms.add(w.slice(0, -1) + 'ies');
  }
  
  // -es â†’ base (e.g., boxes â†’ box, classes â†’ class)
  if (w.endsWith('ses') || w.endsWith('xes') || w.endsWith('zes') || 
      w.endsWith('ches') || w.endsWith('shes')) {
    forms.add(w.slice(0, -2));
  }
  // Add -es for words ending in s, x, z, ch, sh
  if (w.endsWith('s') || w.endsWith('x') || w.endsWith('z') || 
      w.endsWith('ch') || w.endsWith('sh')) {
    forms.add(w + 'es');
  }
  
  // -ves â†’ -f/-fe (e.g., leaves â†’ leaf)
  if (w.endsWith('ves')) {
    forms.add(w.slice(0, -3) + 'f');
    forms.add(w.slice(0, -3) + 'fe');
  }
  // -f/-fe â†’ -ves
  if (w.endsWith('f')) {
    forms.add(w.slice(0, -1) + 'ves');
  }
  if (w.endsWith('fe')) {
    forms.add(w.slice(0, -2) + 'ves');
  }
  
  // Simple -s rule (most common)
  if (w.endsWith('s') && w.length > 2 && !w.endsWith('ss')) {
    forms.add(w.slice(0, -1)); // Remove trailing s
  }
  if (!w.endsWith('s')) {
    forms.add(w + 's'); // Add trailing s
  }
  
  return [...forms];
}

/**
 * Expand a search query using ontology indices
 * @param {string} query - User's search term
 * @returns {string[]} - Array of related tags to search for
 */
function expandQuery(query) {
  const q = query.toLowerCase().trim();
  if (!q) return [];
  
  const terms = new Set([q]);
  
  // Add singular/plural forms of the query
  const queryVariants = normalizePlural(q);
  queryVariants.forEach(form => terms.add(form));
  
  // Helper: check index with all variants of a term
  const checkIndexWithVariants = (index, variants, addRelated = true) => {
    variants.forEach(variant => {
      if (index.has(variant)) {
        terms.add(variant);
        if (addRelated) {
          index.get(variant).forEach(t => {
            terms.add(t);
            // Also add plural/singular of related terms
            normalizePlural(t).forEach(form => terms.add(form));
          });
        }
      }
    });
  };
  
  // 1. Check searchRelations with all variants (primary SSoT for relationships)
  checkIndexWithVariants(relationIndex, queryVariants);
  
  // 2. Check categories with all variants
  checkIndexWithVariants(categoryIndex, queryVariants);
  
  // 3. Check tags with all variants
  checkIndexWithVariants(tagIndex, queryVariants);
  
  // 4. Partial/prefix matches for queries 3+ chars
  // Find any indexed term that STARTS WITH the query (e.g., "notif" â†’ "notification")
  if (q.length >= 3) {
    // Check relation keys for prefix matches
    relationIndex.forEach((related, key) => {
      if (key.startsWith(q)) {
        terms.add(key);
        // Also add plural/singular variants of matched key
        normalizePlural(key).forEach(form => terms.add(form));
      }
    });
    
    // Check category keys for prefix matches
    categoryIndex.forEach((members, cat) => {
      if (cat.startsWith(q)) {
        terms.add(cat);
        normalizePlural(cat).forEach(form => terms.add(form));
      }
      // Also check category members for prefix matches
      members.forEach(member => {
        if (member.startsWith(q)) {
          terms.add(member);
          normalizePlural(member).forEach(form => terms.add(form));
        }
      });
    });
    
    // Check tag keys for prefix matches
    tagIndex.forEach((items, tag) => {
      if (tag.startsWith(q)) {
        terms.add(tag);
        normalizePlural(tag).forEach(form => terms.add(form));
        // Also add the items that have this tag
        items.forEach(item => terms.add(item));
      }
    });
  }
  
  // 5. Component tag variations (handle pds- prefix)
  // Only add the component's tag/name - NOT all its pdsTags (which are too generic)
  if (referenceData?.components) {
    Object.values(referenceData.components).forEach(comp => {
      const tag = comp.tag?.toLowerCase();
      const name = comp.displayName?.toLowerCase();
      const tagWithoutPrefix = tag?.replace('pds-', '');
      
      // Match if query equals, is prefix of, or closely matches the component
      const matchesComponent = 
        tag === q || name === q || tagWithoutPrefix === q ||
        tag?.startsWith(q) || name?.startsWith(q) || tagWithoutPrefix?.startsWith(q) ||
        tag?.includes(q) || name?.includes(q);
        
      if (matchesComponent) {
        terms.add(tag);
        terms.add(tagWithoutPrefix);
        terms.add(name);
      }
    });
  }
  
  // 6. Enhancement selectors - also check prefix matches
  (referenceData?.enhancements || []).forEach(e => {
    const sel = e.selector?.toLowerCase();
    const id = e.id?.toLowerCase();
    const name = e.name?.toLowerCase();
    if (sel?.startsWith(q) || sel?.includes(q) || 
        id?.startsWith(q) || id?.includes(q) ||
        name?.startsWith(q) || name?.includes(q)) {
      terms.add(sel);
      terms.add(id);
      terms.add(name);
    }
  });
  
  // 7. Primitives - check for prefix matches in IDs and tags
  (referenceData?.ontologyData?.primitives || []).forEach(p => {
    const id = p.id?.toLowerCase();
    const pTags = p.tags || [];
    
    if (id?.startsWith(q) || id?.includes(q)) {
      terms.add(id);
      normalizePlural(id).forEach(form => terms.add(form));
    }
    
    pTags.forEach(t => {
      const tLower = t.toLowerCase();
      if (tLower.startsWith(q) || tLower.includes(q)) {
        terms.add(tLower);
        normalizePlural(tLower).forEach(form => terms.add(form));
      }
    });
  });
  
  // 8. Global prefix matching against ALL indexed words
  // This catches anything we might have missed above
  if (q.length >= 3) {
    allWords.forEach(word => {
      if (word.startsWith(q) || word.includes(q)) {
        terms.add(word);
        // Also add plural/singular variants
        normalizePlural(word).forEach(form => terms.add(form));
      }
    });
  }
  
  return Array.from(terms).filter(Boolean);
}

/**
 * Check if a story item matches the search query using ontology relations
 * @param {Object} item - Storybook sidebar item
 * @param {string[]} expandedTerms - Expanded search terms
 * @returns {boolean}
 */
function matchesOntology(item, expandedTerms) {
  if (!expandedTerms.length) return true;
  
  // Build searchable text from item properties
  const searchableParts = [
    item.name,
    item.title,
    item.id,
    item.importPath
  ];
  
  // Include pre-indexed pds.tags for this story (from storyTagsIndex)
  const storyId = item.id?.toLowerCase();
  let foundTags = false;
  
  if (storyId) {
    // Try exact match
    if (storyTagsIndex.has(storyId)) {
      searchableParts.push(...storyTagsIndex.get(storyId));
      foundTags = true;
    }
    
    // Try parent ID (for story variants like "about-pds-what-is-pds--whatispds")
    const parentId = storyId.replace(/--[^-]+$/, '');
    if (parentId !== storyId && storyTagsIndex.has(parentId)) {
      searchableParts.push(...storyTagsIndex.get(parentId));
      foundTags = true;
    }
    
    // Try partial match - check if any indexed ID is contained in this story ID
    if (!foundTags) {
      for (const [indexedId, tags] of storyTagsIndex.entries()) {
        if (storyId.includes(indexedId) || indexedId.includes(storyId)) {
          searchableParts.push(...tags);
          foundTags = true;
          break; // Found a match, no need to continue
        }
      }
    }
  }
  
  const searchableText = searchableParts.filter(Boolean).join(' ').toLowerCase();
  
  // Split searchable text into words for prefix matching
  // Include both space-separated and path-separated words (for IDs like "components-pds-icon")
  const searchableWords = searchableText.split(/[\s\-_/]+/).filter(w => w.length > 0);
  
  // Match if ANY expanded term is found in the searchable text
  // Also check plural/singular variants of each term
  return expandedTerms.some(term => {
    // Direct substring match
    if (searchableText.includes(term)) return true;
    
    // Check plural/singular variants
    const variants = normalizePlural(term);
    if (variants.some(variant => searchableText.includes(variant))) return true;
    
    // Prefix matching for terms 3+ chars (e.g., "notif" matches "notification")
    if (term.length >= 3) {
      if (searchableWords.some(word => word.startsWith(term))) return true;
      // Also check variants as prefixes
      if (variants.some(variant => 
        variant.length >= 3 && searchableWords.some(word => word.startsWith(variant))
      )) return true;
    }
    
    return false;
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STORYBOOK INTEGRATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

addons.register(ADDON_ID, (api) => {
  let currentQuery = '';

  const updateIndicator = (active, terms, noMatches = false) => {
    let indicator = document.getElementById('pds-ontology-indicator');
    if (!indicator) {
      indicator = document.createElement('div');
      indicator.id = 'pds-ontology-indicator';
      indicator.innerHTML = `
        <style>
          #pds-ontology-indicator {
            position: fixed;
            bottom: 8px;
            left: 8px;
            background: var(--sb-bar-background, #1d1d1d);
            border: 1px solid var(--sb-outline, #383838);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 11px;
            color: var(--sb-barTextColor, #999);
            z-index: 100;
            max-width: 280px;
            display: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            pointer-events: none;
          }
          #pds-ontology-indicator.active { display: block; }
          #pds-ontology-indicator .title {
            font-weight: bold;
            color: var(--sb-primary, #029cfd);
            margin-bottom: 4px;
          }
          #pds-ontology-indicator .terms {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
          }
          #pds-ontology-indicator .term {
            background: var(--sb-secondary, #444);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 10px;
          }
          #pds-ontology-indicator .term.original {
            background: var(--sb-primary, #029cfd);
            color: white;
          }
          #pds-ontology-indicator .no-matches {
            color: #f59e0b;
            font-style: italic;
          }
          
          /* PDS Ontology Search: Override Storybook's inline display styles */
          #storybook-explorer-menu > div:last-child { display: none !important; }
          #storybook-explorer-menu > div:first-child { display: block !important; }
          [id^="downshift-"][role="listbox"] { display: none !important; }
          
          /* Hide empty storybook message */
          .css-1w747cv,
          #storybook-explorer-tree > div > div > div > div > div { display: none !important; }
          
          /* Show actual story items */
          #storybook-explorer-tree .sidebar-subheading,
          #storybook-explorer-tree .sidebar-item,
          #storybook-explorer-tree [data-nodetype] { display: flex !important; }
          
          /* No results message */
          #storybook-explorer-tree:not(:has([data-nodetype="story"], [data-nodetype="component"], [data-nodetype="document"]))::after {
            content: "No matching stories. Try: text, form, layout, modal";
            display: block;
            padding: 1rem;
            color: var(--sb-barTextColor, #999);
            font-style: italic;
            text-align: center;
            font-size: 12px;
          }
          
          /* Auto-expand filtered nodes */
          body.pds-filter-active #storybook-explorer-tree [aria-expanded="false"] + div,
          body.pds-filter-active #storybook-explorer-tree [data-nodetype="story"],
          body.pds-filter-active #storybook-explorer-tree [data-nodetype="document"] { display: flex !important; }
          
          body.pds-filter-active #storybook-explorer-tree button[aria-expanded="false"] .css-5ba62h svg,
          body.pds-filter-active #storybook-explorer-tree button[aria-expanded="false"] .css-1yuef8z svg {
            transform: rotate(90deg);
          }
        </style>
        <div class="title">ğŸ” PDS Ontology Search</div>
        <div class="terms"></div>
        <div class="no-matches" style="display: none;">No matches. Try: text, form, layout, modal</div>
      `;
      document.body.appendChild(indicator);
    }
    
    indicator.classList.toggle('active', active);
    document.body.classList.toggle('pds-filter-active', active);
    
    const termsEl = indicator.querySelector('.terms');
    const noMatchesEl = indicator.querySelector('.no-matches');
    
    if (active && noMatches) {
      termsEl.style.display = 'none';
      noMatchesEl.style.display = 'block';
    } else if (active && terms.length) {
      termsEl.style.display = 'flex';
      noMatchesEl.style.display = 'none';
      const originalTerms = currentQuery.split(/\s+/);
      termsEl.innerHTML = terms.slice(0, 20).map(t => 
        `<span class="term${originalTerms.includes(t) ? ' original' : ''}">${t}</span>`
      ).join('');
    } else {
      termsEl.style.display = 'none';
      noMatchesEl.style.display = 'none';
    }
  };

  const applyFilter = (query) => {
    currentQuery = (query || '').trim().toLowerCase();
    
    if (!currentQuery) {
      api.experimental_setFilter(FILTER_ID, () => true);
      updateIndicator(false, [], false);
      return;
    }
    
    const expandedTerms = expandQuery(currentQuery);
    
    api.experimental_setFilter(FILTER_ID, (item) => matchesOntology(item, expandedTerms));
    
    setTimeout(() => {
      const tree = document.getElementById('storybook-explorer-tree');
      const hasVisibleItems = tree && tree.querySelector('[data-highlightable="true"]');
      updateIndicator(true, expandedTerms, !hasVisibleItems);
      
      document.querySelectorAll('#storybook-explorer-menu ol').forEach(ol => {
        ol.style.display = 'none';
      });
    }, 100);
  };

  const hookSearch = () => {
    const searchField = document.getElementById('storybook-explorer-searchfield');
    if (!searchField) {
      requestAnimationFrame(hookSearch);
      return;
    }
    
    if (searchField.dataset.pdsHooked) return;
    searchField.dataset.pdsHooked = 'true';
    
    let debounceTimer;
    searchField.addEventListener('input', (e) => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => applyFilter(e.target.value), 100);
    });
    
    searchField.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') setTimeout(() => applyFilter(''), 10);
    });
    
    searchField.addEventListener('search', () => {
      if (!searchField.value) applyFilter('');
    });
    
    // Watch for the clear button click (the X button in the combobox)
    // The button is a sibling or nearby element that clears the input
    const searchContainer = searchField.closest('[role="search"]') || searchField.parentElement?.parentElement;
    if (searchContainer) {
      searchContainer.addEventListener('click', (e) => {
        // Check if clicked element is a button (clear button) or inside one
        const button = e.target.closest('button');
        if (button && button !== searchField) {
          // Small delay to let the clear action complete
          setTimeout(() => {
            if (!searchField.value) {
              applyFilter('');
            }
          }, 50);
        }
      });
    }
    
    // Also poll for value changes as a fallback (handles programmatic clears)
    let lastValue = searchField.value;
    const checkValue = () => {
      if (searchField.value !== lastValue) {
        lastValue = searchField.value;
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => applyFilter(searchField.value), 100);
      }
      requestAnimationFrame(checkValue);
    };
    checkValue();
  };

  applyFilter('');

  const initializeOntologySearch = async () => {
    await loadOntology();
    hookSearch();
  };

  if (document.readyState === 'complete') {
    setTimeout(initializeOntologySearch, 500);
  } else {
    window.addEventListener('load', () => setTimeout(initializeOntologySearch, 500));
  }

  const mutationObserver = new MutationObserver(() => {
    const searchField = document.getElementById('storybook-explorer-searchfield');
    if (searchField && !searchField.dataset.pdsHooked) hookSearch();
  });
  mutationObserver.observe(document.body, { childList: true, subtree: true });

  // Public API for programmatic search
  window.pdsOntology = {
    search: (query) => {
      const field = document.getElementById('storybook-explorer-searchfield');
      if (field) {
        field.value = query;
        field.dispatchEvent(new Event('input', { bubbles: true }));
      }
      applyFilter(query);
    },
    expand: expandQuery,
    clear: () => {
      const field = document.getElementById('storybook-explorer-searchfield');
      if (field) {
        field.value = '';
        field.dispatchEvent(new Event('input', { bubbles: true }));
      }
      applyFilter('');
    }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // AUTO-SELECT CODE PANEL FOR ENHANCEMENT STORIES
  // Switch to the "Code" panel when navigating to Enhancement stories
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const CODE_PANEL_ID = 'html-preview/panel';
  
  // Listen for story changes and auto-switch panel based on story parameters
  api.on(STORY_CHANGED, (storyId) => {
    if (!storyId) return;
    
    // Get the story data to check its parameters
    const story = api.getData(storyId);
    if (!story) return;
    
    // Check if this is an Enhancement story (by title path)
    const isEnhancement = story.title?.startsWith('Enhancements/');
    
    // Also check parameters.options.selectedPanel
    const selectedPanel = story.parameters?.options?.selectedPanel;
    
    if (isEnhancement || selectedPanel === CODE_PANEL_ID) {
      // Switch to Code panel
      api.setSelectedPanel(CODE_PANEL_ID);
    }
  });
});
